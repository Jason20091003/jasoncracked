/*! For license information please see books.min.js.LICENSE.txt */
(() = >{
    var e = {
        4809 : function(e, t) {
            var r, i, o;
            i = [],
            r = function e() {
                "use strict";
                var t = "undefined" != typeof self ? self: "undefined" != typeof window ? window: void 0 !== t ? t: {},
                r = !t.document && !!t.postMessage,
                i = t.IS_PAPA_WORKER || !1,
                o = {},
                s = 0,
                n = {
                    parse: function(r, i) {
                        var a = (i = i || {}).dynamicTyping || !1;
                        if (v(a) && (i.dynamicTypingFunction = a, a = {}), i.dynamicTyping = a, i.transform = !!v(i.transform) && i.transform, i.worker && n.WORKERS_SUPPORTED) {
                            var d = function() {
                                if (!n.WORKERS_SUPPORTED) return ! 1;
                                var r, i, a = (r = t.URL || t.webkitURL || null, i = e.toString(), n.BLOB_URL || (n.BLOB_URL = r.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i, ")();"], {
                                    type: "text/javascript"
                                })))),
                                d = new t.Worker(a);
                                return d.onmessage = g,
                                d.id = s++,
                                o[d.id] = d
                            } ();
                            return d.userStep = i.step,
                            d.userChunk = i.chunk,
                            d.userComplete = i.complete,
                            d.userError = i.error,
                            i.step = v(i.step),
                            i.chunk = v(i.chunk),
                            i.complete = v(i.complete),
                            i.error = v(i.error),
                            delete i.worker,
                            void d.postMessage({
                                input: r,
                                config: i,
                                workerId: d.id
                            })
                        }
                        var c = null;
                        return n.NODE_STREAM_INPUT,
                        "string" == typeof r ? (r = function(e) {
                            return 65279 === e.charCodeAt(0) ? e.slice(1) : e
                        } (r), c = i.download ? new h(i) : new u(i)) : !0 === r.readable && v(r.read) && v(r.on) ? c = new _(i) : (t.File && r instanceof File || r instanceof Object) && (c = new l(i)),
                        c.stream(r)
                    },
                    unparse: function(e, t) {
                        var r = !1,
                        i = !0,
                        o = ",",
                        s = "\r\n",
                        a = '"',
                        d = a + a,
                        h = !1,
                        l = null,
                        u = !1; !
                        function() {
                            if ("object" == typeof t) {
                                if ("string" != typeof t.delimiter || n.BAD_DELIMITERS.filter((function(e) {
                                    return - 1 !== t.delimiter.indexOf(e)
                                })).length || (o = t.delimiter), ("boolean" == typeof t.quotes || "function" == typeof t.quotes || Array.isArray(t.quotes)) && (r = t.quotes), "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (h = t.skipEmptyLines), "string" == typeof t.newline && (s = t.newline), "string" == typeof t.quoteChar && (a = t.quoteChar), "boolean" == typeof t.header && (i = t.header), Array.isArray(t.columns)) {
                                    if (0 === t.columns.length) throw new Error("Option columns is empty");
                                    l = t.columns
                                }
                                void 0 !== t.escapeChar && (d = t.escapeChar + a),
                                ("boolean" == typeof t.escapeFormulae || t.escapeFormulae instanceof RegExp) && (u = t.escapeFormulae instanceof RegExp ? t.escapeFormulae: /^[=+\-@\t\r].*$/)
                            }
                        } ();
                        var _ = new RegExp(f(a), "g");
                        if ("string" == typeof e && (e = JSON.parse(e)), Array.isArray(e)) {
                            if (!e.length || Array.isArray(e[0])) return c(null, e, h);
                            if ("object" == typeof e[0]) return c(l || Object.keys(e[0]), e, h)
                        } else if ("object" == typeof e) return "string" == typeof e.data && (e.data = JSON.parse(e.data)),
                        Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || l), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields: "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])),
                        c(e.fields || [], e.data || [], h);
                        throw new Error("Unable to serialize unrecognized input");
                        function c(e, t, r) {
                            var n = "";
                            "string" == typeof e && (e = JSON.parse(e)),
                            "string" == typeof t && (t = JSON.parse(t));
                            var a = Array.isArray(e) && 0 < e.length,
                            d = !Array.isArray(t[0]);
                            if (a && i) {
                                for (var h = 0; h < e.length; h++) 0 < h && (n += o),
                                n += p(e[h], h);
                                0 < t.length && (n += s)
                            }
                            for (var l = 0; l < t.length; l++) {
                                var u = a ? e.length: t[l].length,
                                _ = !1,
                                c = a ? 0 === Object.keys(t[l]).length: 0 === t[l].length;
                                if (r && !a && (_ = "greedy" === r ? "" === t[l].join("").trim() : 1 === t[l].length && 0 === t[l][0].length), "greedy" === r && a) {
                                    for (var f = [], g = 0; g < u; g++) {
                                        var m = d ? e[g] : g;
                                        f.push(t[l][m])
                                    }
                                    _ = "" === f.join("").trim()
                                }
                                if (!_) {
                                    for (var w = 0; w < u; w++) {
                                        0 < w && !c && (n += o);
                                        var k = a && d ? e[w] : w;
                                        n += p(t[l][k], w)
                                    }
                                    l < t.length - 1 && (!r || 0 < u && !c) && (n += s)
                                }
                            }
                            return n
                        }
                        function p(e, t) {
                            if (null == e) return "";
                            if (e.constructor === Date) return JSON.stringify(e).slice(1, 25);
                            var i = !1;
                            u && "string" == typeof e && u.test(e) && (e = "'" + e, i = !0);
                            var s = e.toString().replace(_, d);
                            return (i = i || !0 === r || "function" == typeof r && r(e, t) || Array.isArray(r) && r[t] ||
                            function(e, t) {
                                for (var r = 0; r < t.length; r++) if ( - 1 < e.indexOf(t[r])) return ! 0;
                                return ! 1
                            } (s, n.BAD_DELIMITERS) || -1 < s.indexOf(o) || " " === s.charAt(0) || " " === s.charAt(s.length - 1)) ? a + s + a: s
                        }
                    }
                };
                if (n.RECORD_SEP = String.fromCharCode(30), n.UNIT_SEP = String.fromCharCode(31), n.BYTE_ORDER_MARK = "\ufeff", n.BAD_DELIMITERS = ["\r", "\n", '"', n.BYTE_ORDER_MARK], n.WORKERS_SUPPORTED = !r && !!t.Worker, n.NODE_STREAM_INPUT = 1, n.LocalChunkSize = 10485760, n.RemoteChunkSize = 5242880, n.DefaultDelimiter = ",", n.Parser = p, n.ParserHandle = c, n.NetworkStreamer = h, n.FileStreamer = l, n.StringStreamer = u, n.ReadableStreamStreamer = _, t.jQuery) {
                    var a = t.jQuery;
                    a.fn.parse = function(e) {
                        var r = e.config || {},
                        i = [];
                        return this.each((function(e) {
                            if ("INPUT" !== a(this).prop("tagName").toUpperCase() || "file" !== a(this).attr("type").toLowerCase() || !t.FileReader || !this.files || 0 === this.files.length) return ! 0;
                            for (var o = 0; o < this.files.length; o++) i.push({
                                file: this.files[o],
                                inputElem: this,
                                instanceConfig: a.extend({},
                                r)
                            })
                        })),
                        o(),
                        this;
                        function o() {
                            if (0 !== i.length) {
                                var t, r, o, d, h = i[0];
                                if (v(e.before)) {
                                    var l = e.before(h.file, h.inputElem);
                                    if ("object" == typeof l) {
                                        if ("abort" === l.action) return t = "AbortError",
                                        r = h.file,
                                        o = h.inputElem,
                                        d = l.reason,
                                        void(v(e.error) && e.error({
                                            name: t
                                        },
                                        r, o, d));
                                        if ("skip" === l.action) return void s();
                                        "object" == typeof l.config && (h.instanceConfig = a.extend(h.instanceConfig, l.config))
                                    } else if ("skip" === l) return void s()
                                }
                                var u = h.instanceConfig.complete;
                                h.instanceConfig.complete = function(e) {
                                    v(u) && u(e, h.file, h.inputElem),
                                    s()
                                },
                                n.parse(h.file, h.instanceConfig)
                            } else v(e.complete) && e.complete()
                        }
                        function s() {
                            i.splice(0, 1),
                            o()
                        }
                    }
                }
                function d(e) {
                    this._handle = null,
                    this._finished = !1,
                    this._completed = !1,
                    this._halted = !1,
                    this._input = null,
                    this._baseIndex = 0,
                    this._partialLine = "",
                    this._rowCount = 0,
                    this._start = 0,
                    this._nextChunk = null,
                    this.isFirstChunk = !0,
                    this._completeResults = {
                        data: [],
                        errors: [],
                        meta: {}
                    },
                    function(e) {
                        var t = k(e);
                        t.chunkSize = parseInt(t.chunkSize),
                        e.step || e.chunk || (t.chunkSize = null),
                        this._handle = new c(t),
                        (this._handle.streamer = this)._config = t
                    }.call(this, e),
                    this.parseChunk = function(e, r) {
                        if (this.isFirstChunk && v(this._config.beforeFirstChunk)) {
                            var o = this._config.beforeFirstChunk(e);
                            void 0 !== o && (e = o)
                        }
                        this.isFirstChunk = !1,
                        this._halted = !1;
                        var s = this._partialLine + e;
                        this._partialLine = "";
                        var a = this._handle.parse(s, this._baseIndex, !this._finished);
                        if (!this._handle.paused() && !this._handle.aborted()) {
                            var d = a.meta.cursor;
                            this._finished || (this._partialLine = s.substring(d - this._baseIndex), this._baseIndex = d),
                            a && a.data && (this._rowCount += a.data.length);
                            var h = this._finished || this._config.preview && this._rowCount >= this._config.preview;
                            if (i) t.postMessage({
                                results: a,
                                workerId: n.WORKER_ID,
                                finished: h
                            });
                            else if (v(this._config.chunk) && !r) {
                                if (this._config.chunk(a, this._handle), this._handle.paused() || this._handle.aborted()) return void(this._halted = !0);
                                a = void 0,
                                this._completeResults = void 0
                            }
                            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(a.data), this._completeResults.errors = this._completeResults.errors.concat(a.errors), this._completeResults.meta = a.meta),
                            this._completed || !h || !v(this._config.complete) || a && a.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0),
                            h || a && a.meta.paused || this._nextChunk(),
                            a
                        }
                        this._halted = !0
                    },
                    this._sendError = function(e) {
                        v(this._config.error) ? this._config.error(e) : i && this._config.error && t.postMessage({
                            workerId: n.WORKER_ID,
                            error: e,
                            finished: !1
                        })
                    }
                }
                function h(e) {
                    var t; (e = e || {}).chunkSize || (e.chunkSize = n.RemoteChunkSize),
                    d.call(this, e),
                    this._nextChunk = r ?
                    function() {
                        this._readChunk(),
                        this._chunkLoaded()
                    }: function() {
                        this._readChunk()
                    },
                    this.stream = function(e) {
                        this._input = e,
                        this._nextChunk()
                    },
                    this._readChunk = function() {
                        if (this._finished) this._chunkLoaded();
                        else {
                            if (t = new XMLHttpRequest, this._config.withCredentials && (t.withCredentials = this._config.withCredentials), r || (t.onload = b(this._chunkLoaded, this), t.onerror = b(this._chunkError, this)), t.open(this._config.downloadRequestBody ? "POST": "GET", this._input, !r), this._config.downloadRequestHeaders) {
                                var e = this._config.downloadRequestHeaders;
                                for (var i in e) t.setRequestHeader(i, e[i])
                            }
                            if (this._config.chunkSize) {
                                var o = this._start + this._config.chunkSize - 1;
                                t.setRequestHeader("Range", "bytes=" + this._start + "-" + o)
                            }
                            try {
                                t.send(this._config.downloadRequestBody)
                            } catch(e) {
                                this._chunkError(e.message)
                            }
                            r && 0 === t.status && this._chunkError()
                        }
                    },
                    this._chunkLoaded = function() {
                        4 === t.readyState && (t.status < 200 || 400 <= t.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize: t.responseText.length, this._finished = !this._config.chunkSize || this._start >=
                        function(e) {
                            var t = e.getResponseHeader("Content-Range");
                            return null === t ? -1 : parseInt(t.substring(t.lastIndexOf("/") + 1))
                        } (t), this.parseChunk(t.responseText)))
                    },
                    this._chunkError = function(e) {
                        var r = t.statusText || e;
                        this._sendError(new Error(r))
                    }
                }
                function l(e) {
                    var t, r; (e = e || {}).chunkSize || (e.chunkSize = n.LocalChunkSize),
                    d.call(this, e);
                    var i = "undefined" != typeof FileReader;
                    this.stream = function(e) {
                        this._input = e,
                        r = e.slice || e.webkitSlice || e.mozSlice,
                        i ? ((t = new FileReader).onload = b(this._chunkLoaded, this), t.onerror = b(this._chunkError, this)) : t = new FileReaderSync,
                        this._nextChunk()
                    },
                    this._nextChunk = function() {
                        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk()
                    },
                    this._readChunk = function() {
                        var e = this._input;
                        if (this._config.chunkSize) {
                            var o = Math.min(this._start + this._config.chunkSize, this._input.size);
                            e = r.call(e, this._start, o)
                        }
                        var s = t.readAsText(e, this._config.encoding);
                        i || this._chunkLoaded({
                            target: {
                                result: s
                            }
                        })
                    },
                    this._chunkLoaded = function(e) {
                        this._start += this._config.chunkSize,
                        this._finished = !this._config.chunkSize || this._start >= this._input.size,
                        this.parseChunk(e.target.result)
                    },
                    this._chunkError = function() {
                        this._sendError(t.error)
                    }
                }
                function u(e) {
                    var t;
                    d.call(this, e = e || {}),
                    this.stream = function(e) {
                        return t = e,
                        this._nextChunk()
                    },
                    this._nextChunk = function() {
                        if (!this._finished) {
                            var e, r = this._config.chunkSize;
                            return r ? (e = t.substring(0, r), t = t.substring(r)) : (e = t, t = ""),
                            this._finished = !t,
                            this.parseChunk(e)
                        }
                    }
                }
                function _(e) {
                    d.call(this, e = e || {});
                    var t = [],
                    r = !0,
                    i = !1;
                    this.pause = function() {
                        d.prototype.pause.apply(this, arguments),
                        this._input.pause()
                    },
                    this.resume = function() {
                        d.prototype.resume.apply(this, arguments),
                        this._input.resume()
                    },
                    this.stream = function(e) {
                        this._input = e,
                        this._input.on("data", this._streamData),
                        this._input.on("end", this._streamEnd),
                        this._input.on("error", this._streamError)
                    },
                    this._checkIsFinished = function() {
                        i && 1 === t.length && (this._finished = !0)
                    },
                    this._nextChunk = function() {
                        this._checkIsFinished(),
                        t.length ? this.parseChunk(t.shift()) : r = !0
                    },
                    this._streamData = b((function(e) {
                        try {
                            t.push("string" == typeof e ? e: e.toString(this._config.encoding)),
                            r && (r = !1, this._checkIsFinished(), this.parseChunk(t.shift()))
                        } catch(e) {
                            this._streamError(e)
                        }
                    }), this),
                    this._streamError = b((function(e) {
                        this._streamCleanUp(),
                        this._sendError(e)
                    }), this),
                    this._streamEnd = b((function() {
                        this._streamCleanUp(),
                        i = !0,
                        this._streamData("")
                    }), this),
                    this._streamCleanUp = b((function() {
                        this._input.removeListener("data", this._streamData),
                        this._input.removeListener("end", this._streamEnd),
                        this._input.removeListener("error", this._streamError)
                    }), this)
                }
                function c(e) {
                    var t, r, i, o = Math.pow(2, 53),
                    s = -o,
                    a = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,
                    d = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,
                    h = this,
                    l = 0,
                    u = 0,
                    _ = !1,
                    c = !1,
                    g = [],
                    m = {
                        data: [],
                        errors: [],
                        meta: {}
                    };
                    if (v(e.step)) {
                        var w = e.step;
                        e.step = function(t) {
                            if (m = t, x()) y();
                            else {
                                if (y(), 0 === m.data.length) return;
                                l += t.data.length,
                                e.preview && l > e.preview ? r.abort() : (m.data = m.data[0], w(m, h))
                            }
                        }
                    }
                    function b(t) {
                        return "greedy" === e.skipEmptyLines ? "" === t.join("").trim() : 1 === t.length && 0 === t[0].length
                    }
                    function y() {
                        return m && i && (S("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + n.DefaultDelimiter + "'"), i = !1),
                        e.skipEmptyLines && (m.data = m.data.filter((function(e) {
                            return ! b(e)
                        }))),
                        x() &&
                        function() {
                            if (m) if (Array.isArray(m.data[0])) {
                                for (var t = 0; x() && t < m.data.length; t++) m.data[t].forEach(r);
                                m.data.splice(0, 1)
                            } else m.data.forEach(r);
                            function r(t, r) {
                                v(e.transformHeader) && (t = e.transformHeader(t, r)),
                                g.push(t)
                            }
                        } (),
                        function() {
                            if (!m || !e.header && !e.dynamicTyping && !e.transform) return m;
                            function t(t, r) {
                                var i, o = e.header ? {}: [];
                                for (i = 0; i < t.length; i++) {
                                    var s = i,
                                    n = t[i];
                                    e.header && (s = i >= g.length ? "__parsed_extra": g[i]),
                                    e.transform && (n = e.transform(n, s)),
                                    n = E(s, n),
                                    "__parsed_extra" === s ? (o[s] = o[s] || [], o[s].push(n)) : o[s] = n
                                }
                                return e.header && (i > g.length ? S("FieldMismatch", "TooManyFields", "Too many fields: expected " + g.length + " fields but parsed " + i, u + r) : i < g.length && S("FieldMismatch", "TooFewFields", "Too few fields: expected " + g.length + " fields but parsed " + i, u + r)),
                                o
                            }
                            var r = 1;
                            return ! m.data.length || Array.isArray(m.data[0]) ? (m.data = m.data.map(t), r = m.data.length) : m.data = t(m.data, 0),
                            e.header && m.meta && (m.meta.fields = g),
                            u += r,
                            m
                        } ()
                    }
                    function x() {
                        return e.header && 0 === g.length
                    }
                    function E(t, r) {
                        return i = t,
                        e.dynamicTypingFunction && void 0 === e.dynamicTyping[i] && (e.dynamicTyping[i] = e.dynamicTypingFunction(i)),
                        !0 === (e.dynamicTyping[i] || e.dynamicTyping) ? "true" === r || "TRUE" === r || "false" !== r && "FALSE" !== r && (function(e) {
                            if (a.test(e)) {
                                var t = parseFloat(e);
                                if (s < t && t < o) return ! 0
                            }
                            return ! 1
                        } (r) ? parseFloat(r) : d.test(r) ? new Date(r) : "" === r ? null: r) : r;
                        var i
                    }
                    function S(e, t, r, i) {
                        var o = {
                            type: e,
                            code: t,
                            message: r
                        };
                        void 0 !== i && (o.row = i),
                        m.errors.push(o)
                    }
                    this.parse = function(o, s, a) {
                        var d = e.quoteChar || '"';
                        if (e.newline || (e.newline = function(e, t) {
                            e = e.substring(0, 1048576);
                            var r = new RegExp(f(t) + "([^]*?)" + f(t), "gm"),
                            i = (e = e.replace(r, "")).split("\r"),
                            o = e.split("\n"),
                            s = 1 < o.length && o[0].length < i[0].length;
                            if (1 === i.length || s) return "\n";
                            for (var n = 0,
                            a = 0; a < i.length; a++)"\n" === i[a][0] && n++;
                            return n >= i.length / 2 ? "\r\n": "\r"
                        } (o, d)), i = !1, e.delimiter) v(e.delimiter) && (e.delimiter = e.delimiter(o), m.meta.delimiter = e.delimiter);
                        else {
                            var h = function(t, r, i, o, s) {
                                var a, d, h, l;
                                s = s || [",", "\t", "|", ";", n.RECORD_SEP, n.UNIT_SEP];
                                for (var u = 0; u < s.length; u++) {
                                    var _ = s[u],
                                    c = 0,
                                    f = 0,
                                    g = 0;
                                    h = void 0;
                                    for (var m = new p({
                                        comments: o,
                                        delimiter: _,
                                        newline: r,
                                        preview: 10
                                    }).parse(t), w = 0; w < m.data.length; w++) if (i && b(m.data[w])) g++;
                                    else {
                                        var k = m.data[w].length;
                                        f += k,
                                        void 0 !== h ? 0 < k && (c += Math.abs(k - h), h = k) : h = k
                                    }
                                    0 < m.data.length && (f /= m.data.length - g),
                                    (void 0 === d || c <= d) && (void 0 === l || l < f) && 1.99 < f && (d = c, a = _, l = f)
                                }
                                return {
                                    successful: !!(e.delimiter = a),
                                    bestDelimiter: a
                                }
                            } (o, e.newline, e.skipEmptyLines, e.comments, e.delimitersToGuess);
                            h.successful ? e.delimiter = h.bestDelimiter: (i = !0, e.delimiter = n.DefaultDelimiter),
                            m.meta.delimiter = e.delimiter
                        }
                        var l = k(e);
                        return e.preview && e.header && l.preview++,
                        t = o,
                        r = new p(l),
                        m = r.parse(t, s, a),
                        y(),
                        _ ? {
                            meta: {
                                paused: !0
                            }
                        }: m || {
                            meta: {
                                paused: !1
                            }
                        }
                    },
                    this.paused = function() {
                        return _
                    },
                    this.pause = function() {
                        _ = !0,
                        r.abort(),
                        t = v(e.chunk) ? "": t.substring(r.getCharIndex())
                    },
                    this.resume = function() {
                        h.streamer._halted ? (_ = !1, h.streamer.parseChunk(t, !0)) : setTimeout(h.resume, 3)
                    },
                    this.aborted = function() {
                        return c
                    },
                    this.abort = function() {
                        c = !0,
                        r.abort(),
                        m.meta.aborted = !0,
                        v(e.complete) && e.complete(m),
                        t = ""
                    }
                }
                function f(e) {
                    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
                }
                function p(e) {
                    var t, r = (e = e || {}).delimiter,
                    i = e.newline,
                    o = e.comments,
                    s = e.step,
                    a = e.preview,
                    d = e.fastMode,
                    h = t = void 0 === e.quoteChar || null === e.quoteChar ? '"': e.quoteChar;
                    if (void 0 !== e.escapeChar && (h = e.escapeChar), ("string" != typeof r || -1 < n.BAD_DELIMITERS.indexOf(r)) && (r = ","), o === r) throw new Error("Comment character same as delimiter"); ! 0 === o ? o = "#": ("string" != typeof o || -1 < n.BAD_DELIMITERS.indexOf(o)) && (o = !1),
                    "\n" !== i && "\r" !== i && "\r\n" !== i && (i = "\n");
                    var l = 0,
                    u = !1;
                    this.parse = function(n, _, c) {
                        if ("string" != typeof n) throw new Error("Input must be a string");
                        var p = n.length,
                        g = r.length,
                        m = i.length,
                        w = o.length,
                        k = v(s),
                        b = [],
                        y = [],
                        x = [],
                        E = l = 0;
                        if (!n) return K();
                        if (e.header && !_) {
                            var S = n.split(i)[0].split(r),
                            C = [],
                            O = {},
                            R = !1;
                            for (var $ in S) {
                                var I = S[$];
                                v(e.transformHeader) && (I = e.transformHeader(I, $));
                                var A = I,
                                D = O[I] || 0;
                                for (0 < D && (R = !0, A = I + "_" + D), O[I] = D + 1; C.includes(A);) A = A + "_" + D;
                                C.push(A)
                            }
                            if (R) {
                                var T = n.split(i);
                                T[0] = C.join(r),
                                n = T.join(i)
                            }
                        }
                        if (d || !1 !== d && -1 === n.indexOf(t)) {
                            for (var z = n.split(i), L = 0; L < z.length; L++) {
                                if (x = z[L], l += x.length, L !== z.length - 1) l += i.length;
                                else if (c) return K();
                                if (!o || x.substring(0, w) !== o) {
                                    if (k) {
                                        if (b = [], U(x.split(r)), H(), u) return K()
                                    } else U(x.split(r));
                                    if (a && a <= L) return b = b.slice(0, a),
                                    K(!0)
                                }
                            }
                            return K()
                        }
                        for (var F = n.indexOf(r, l), j = n.indexOf(i, l), P = new RegExp(f(h) + f(t), "g"), M = n.indexOf(t, l);;) if (n[l] !== t) if (o && 0 === x.length && n.substring(l, l + w) === o) {
                            if ( - 1 === j) return K();
                            l = j + m,
                            j = n.indexOf(i, l),
                            F = n.indexOf(r, l)
                        } else if ( - 1 !== F && (F < j || -1 === j)) x.push(n.substring(l, F)),
                        l = F + g,
                        F = n.indexOf(r, l);
                        else {
                            if ( - 1 === j) break;
                            if (x.push(n.substring(l, j)), J(j + m), k && (H(), u)) return K();
                            if (a && b.length >= a) return K(!0)
                        } else for (M = l, l++;;) {
                            if ( - 1 === (M = n.indexOf(t, M + 1))) return c || y.push({
                                type: "Quotes",
                                code: "MissingQuotes",
                                message: "Quoted field unterminated",
                                row: b.length,
                                index: l
                            }),
                            W();
                            if (M === p - 1) return W(n.substring(l, M).replace(P, t));
                            if (t !== h || n[M + 1] !== h) {
                                if (t === h || 0 === M || n[M - 1] !== h) { - 1 !== F && F < M + 1 && (F = n.indexOf(r, M + 1)),
                                    -1 !== j && j < M + 1 && (j = n.indexOf(i, M + 1));
                                    var q = B( - 1 === j ? F: Math.min(F, j));
                                    if (n.substr(M + 1 + q, g) === r) {
                                        x.push(n.substring(l, M).replace(P, t)),
                                        n[l = M + 1 + q + g] !== t && (M = n.indexOf(t, l)),
                                        F = n.indexOf(r, l),
                                        j = n.indexOf(i, l);
                                        break
                                    }
                                    var N = B(j);
                                    if (n.substring(M + 1 + N, M + 1 + N + m) === i) {
                                        if (x.push(n.substring(l, M).replace(P, t)), J(M + 1 + N + m), F = n.indexOf(r, l), M = n.indexOf(t, l), k && (H(), u)) return K();
                                        if (a && b.length >= a) return K(!0);
                                        break
                                    }
                                    y.push({
                                        type: "Quotes",
                                        code: "InvalidQuotes",
                                        message: "Trailing quote on quoted field is malformed",
                                        row: b.length,
                                        index: l
                                    }),
                                    M++
                                }
                            } else M++
                        }
                        return W();
                        function U(e) {
                            b.push(e),
                            E = l
                        }
                        function B(e) {
                            var t = 0;
                            if ( - 1 !== e) {
                                var r = n.substring(M + 1, e);
                                r && "" === r.trim() && (t = r.length)
                            }
                            return t
                        }
                        function W(e) {
                            return c || (void 0 === e && (e = n.substring(l)), x.push(e), l = p, U(x), k && H()),
                            K()
                        }
                        function J(e) {
                            l = e,
                            U(x),
                            x = [],
                            j = n.indexOf(i, l)
                        }
                        function K(e) {
                            return {
                                data: b,
                                errors: y,
                                meta: {
                                    delimiter: r,
                                    linebreak: i,
                                    aborted: u,
                                    truncated: !!e,
                                    cursor: E + (_ || 0)
                                }
                            }
                        }
                        function H() {
                            s(K()),
                            b = [],
                            y = []
                        }
                    },
                    this.abort = function() {
                        u = !0
                    },
                    this.getCharIndex = function() {
                        return l
                    }
                }
                function g(e) {
                    var t = e.data,
                    r = o[t.workerId],
                    i = !1;
                    if (t.error) r.userError(t.error, t.file);
                    else if (t.results && t.results.data) {
                        var s = {
                            abort: function() {
                                i = !0,
                                m(t.workerId, {
                                    data: [],
                                    errors: [],
                                    meta: {
                                        aborted: !0
                                    }
                                })
                            },
                            pause: w,
                            resume: w
                        };
                        if (v(r.userStep)) {
                            for (var n = 0; n < t.results.data.length && (r.userStep({
                                data: t.results.data[n],
                                errors: t.results.errors,
                                meta: t.results.meta
                            },
                            s), !i); n++);
                            delete t.results
                        } else v(r.userChunk) && (r.userChunk(t.results, s, t.file), delete t.results)
                    }
                    t.finished && !i && m(t.workerId, t.results)
                }
                function m(e, t) {
                    var r = o[e];
                    v(r.userComplete) && r.userComplete(t),
                    r.terminate(),
                    delete o[e]
                }
                function w() {
                    throw new Error("Not implemented.")
                }
                function k(e) {
                    if ("object" != typeof e || null === e) return e;
                    var t = Array.isArray(e) ? [] : {};
                    for (var r in e) t[r] = k(e[r]);
                    return t
                }
                function b(e, t) {
                    return function() {
                        e.apply(t, arguments)
                    }
                }
                function v(e) {
                    return "function" == typeof e
                }
                return i && (t.onmessage = function(e) {
                    var r = e.data;
                    if (void 0 === n.WORKER_ID && r && (n.WORKER_ID = r.workerId), "string" == typeof r.input) t.postMessage({
                        workerId: n.WORKER_ID,
                        results: n.parse(r.input, r.config),
                        finished: !0
                    });
                    else if (t.File && r.input instanceof File || r.input instanceof Object) {
                        var i = n.parse(r.input, r.config);
                        i && t.postMessage({
                            workerId: n.WORKER_ID,
                            results: i,
                            finished: !0
                        })
                    }
                }),
                (h.prototype = Object.create(d.prototype)).constructor = h,
                (l.prototype = Object.create(d.prototype)).constructor = l,
                (u.prototype = Object.create(u.prototype)).constructor = u,
                (_.prototype = Object.create(d.prototype)).constructor = _,
                n
            },
            void 0 === (o = "function" == typeof r ? r.apply(t, i) : r) || (e.exports = o)
        }
    },
    t = {};
    function r(i) {
        var o = t[i];
        if (void 0 !== o) return o.exports;
        var s = t[i] = {
            exports: {}
        };
        return e[i].call(s.exports, s, s.exports, r),
        s.exports
    }
    r.n = e = >{
        var t = e && e.__esModule ? () = >e.
    default:
        () = >e;
        return r.d(t, {
            a: t
        }),
        t
    },
    r.d = (e, t) = >{
        for (var i in t) r.o(t, i) && !r.o(e, i) && Object.defineProperty(e, i, {
            enumerable: !0,
            get: t[i]
        })
    },
    r.o = (e, t) = >Object.prototype.hasOwnProperty.call(e, t),
    (() = >{
        "use strict";
        var e = r(4809),
        t = r.n(e);
        const i = {
            page_data: {
                book_info: {},
                book_objs: [],
                user_books: [],
                user_book_page: 0,
                learn_book: null,
                add_modal_show: !1,
                new_user_book: {
                    name: ""
                },
                user_book: {
                    id: "",
                    name: "",
                    words: [],
                    translations: {}
                },
                new_words_data: [],
                merge_modal_show: !1,
                merge_book_start: !1,
                merge_book_mode: "tail",
                merge_book_type: "",
                merge_book_loaded_num: 0,
                merge_book: {
                    newname: "",
                    selecting: "",
                    target_book: {},
                    target_book_detail: {},
                    other_book: {},
                    other_book_detail: {}
                },
                import_words: [],
                import_words_data: [],
                import_words_page: 0,
                custom_words: [],
                custom_words_data: [],
                custom_word_data_input: {
                    word: "",
                    meaning: "",
                    pos: ""
                },
                search_input: "",
                search_word: {
                    word: ""
                },
                add_type: 0,
                words_collapse: !0,
                words_collapse_max: 10,
                words_custom_modal_show: !1,
                words_custom_add_backward: !0
            },
            page_methods: {
                init() {
                    let e = localStorage.getItem("$$words_custom_add_backward"); ! 1 !== e && "false" !== e || (this.words_custom_add_backward = !1),
                    this.refresh()
                },
                refresh() {
                    urlParam("nob") && i$.toast.info("单词书不存在，已被删除或者丢失，请重新选择。"),
                    (e = >{
                        let t;
                        i$.cache.get("token") ? i$.http.get("api/user/record/book/info", {
                            loading: !1
                        }).then((r = >{
                            if (r && r.total && r.total > 0 ? (t = {
                                description: r.description,
                                total: r.total,
                                days: r.days,
                                day: r.day,
                                id: r.id,
                                name: r.name,
                                size: r.size,
                                random: r.random,
                                start: r.start,
                                pronounce: r.pronounce,
                                learned: r.learned
                            },
                            i$.cache.put("book_info", t)) : "" === r && (t = i$.cache.get("book_info")), "function" == typeof e) {
                                let i = "/book?id=" + t.id;
                                r.type ? i += "&type=" + r.type: i += "&type=DEFAULT",
                                t.addr = i,
                                e(t)
                            }
                        })).
                        catch((t = >{
                            "function" == typeof e && e(t)
                        })) : (t = i$.cache.get("book_info")) ? "function" == typeof e && e(t) : "function" == typeof e && e(null)
                    })((e = >{
                        this.book_info = e,
                        this.request_books(e),
                        this.request_user_books(e)
                    }))
                },
                request_books(e) {
                    i$.http.get("api/book/en/zh/books").then((t = >{
                        if (! (t && t instanceof Array)) return;
                        let r,
                        i = [],
                        s = [],
                        n = null;
                        for (let r in t) {
                            let o = t[r];
                            e && o.id == e.id ? (o.learning = !0, n = o, o.cover = this.format_image_resource(o.properties.cover)) : (o.cover = this.format_image_resource(o.properties.cover), i.push(o))
                        }
                        n && i.unshift(n);
                        for (let e in i) r = i[e],
                        s.push(o(r));
                        this.book_objs = s
                    }))
                },
                request_user_books(e) {
                    this.is_online() && i$.http.get("api/book/en/zh/books?type=ENGLISH_CHINESE_CUSTOM_BOOK").then((t = >{
                        if (t instanceof Array) {
                            let r,
                            i = [];
                            for (let o in t) r = t[o],
                            i.push({
                                bookId: r.id,
                                name: r.name,
                                total: r.total,
                                nickname: r.properties.nickname,
                                learning: e.id == r.id,
                                url: "/book?id=" + r.id
                            });
                            this.user_books = i
                        }
                    }))
                },
                toggle_add_modal(e) {
                    this.is_online() || i$.cache.get("token") ? (this.import_words_data = [], this.import_words = [], this.custom_words = [], this.custom_words_data = [], this.custom_word_data_input = {
                        word: "",
                        meaning: "",
                        pos: ""
                    },
                    e ? i$.http.get("api/book/en/zh/book/custom/detail?id=" + e).then((e = >{
                        e && e.id && (this.user_book = {
                            id: e.id,
                            name: e.name,
                            words: e.words
                        })
                    })).
                    catch((e = >{
                        console.log(e)
                    })) : (this.user_book = {
                        id: "",
                        name: "",
                        words: []
                    },
                    this.add_type = 0), this.add_modal_show = !this.add_modal_show, this.add_modal_show || this.request_user_books(this.book_info)) : i$.toast.warn("登录后才可自定义单词书")
                },
                close_add_modal() {
                    i$.popup.confirm("关闭后未保存的修改内容将会丢失！", {},
                    (() = >{
                        this.toggle_add_modal()
                    }))
                },
                toggle_add_type(e) {
                    this.add_type = e
                },
                toggle_merge_modal() {
                    this.is_online() || i$.cache.get("token") ? (this.merge_book_start = !1, this.merge_modal_show ? this.merge_modal_show = !1 : (this.merge_book_clear(), this.merge_modal_show = !0)) : i$.toast.warn("登录后才可合并单词书")
                },
                toggle_words_collapse() {
                    this.user_book.words.length <= this.words_collapse_max ? this.words_collapse = !1 : this.words_collapse = !this.words_collapse
                },
                toggle_words_custom_modal() {
                    this.words_custom_modal_show = !this.words_custom_modal_show
                },
                select_file() {
                    let e = document.getElementById("wordsFile").files[0];
                    if (e) {
                        if (e.size > 1e9) return;
                        this.import_words_data = [],
                        this.import_words = [];
                        const t = e.name;
                        t.endsWith(".csv") ? this.read_csv_file(e) : t.endsWith(".xls") || t.endsWith(".xlsx") ? loadJs("/static/js/excel.min.js", (() = >{
                            this.read_excel_file(e)
                        })) : this.read_text_File(e)
                    }
                },
                remove_word(e) {
                    let t = this.user_book.words;
                    e >= 0 && e < t.length && this.user_book.words.splice(e, 1),
                    this.user_book.words.length <= this.words_collapse_max && (this.words_collapse = !1)
                },
                add_from_import() {
                    let e = this.import_words;
                    if (!e || 0 == e.length) return void i$.toast.info("先导入文件"); (new Date).getTime();
                    let t = this.user_book.words || [],
                    r = this.words_custom_add_backward;
                    if (t = !0 === r || "true" === r ? t.concat(e) : e.concat(t), document.getElementById("wordsFile").value = "", this.user_book.words = this.duplicate(t), this.import_words = [], this.import_words_data && this.import_words_data.length > 0) {
                        let e = this.new_words_data || [];
                        this.new_words_data = e.concat(this.import_words_data),
                        this.import_words_data = []
                    }
                },
                clear_import() {
                    this.import_words = [],
                    document.getElementById("wordsFile").value = ""
                },
                add_from_search() {
                    if (this.search_word && this.search_word.id) {
                        let e = this.search_word.word;
                        const t = this.user_book.words;
                        for (let r in t) if (e == t[r]) {
                            i$.toast.warn("单词书中已存在单词：" + e),
                            e = "";
                            break
                        }
                        if (e) {
                            let t = this.words_custom_add_backward; ! 0 === t || "true" === t ? this.user_book.words.push(e) : this.user_book.words.unshift(e),
                            this.search_word = {
                                word: ""
                            }
                        }
                    }
                },
                add_from_custom() {
                    const e = this.custom_words;
                    if (0 == e.length) return void i$.toast.info("请先输入自定义单词");
                    let t = this.user_book.words || [],
                    r = this.words_custom_add_backward;
                    if (t = !0 === r || "true" === r ? t.concat(e) : e.concat(t), this.user_book.words = this.duplicate(t), this.custom_words_data && this.custom_words_data.length > 0) {
                        let e = this.new_words_data || [];
                        this.new_words_data = e.concat(this.custom_words_data),
                        this.custom_words_data = []
                    }
                    console.log(JSON.parse(JSON.stringify(e))),
                    console.log(JSON.parse(JSON.stringify(this.custom_words_data))),
                    this.custom_words = []
                },
                delete_from_custom_words(e) {
                    if (e) {
                        let t = this.custom_words_data;
                        for (let r in t) if (t[r].word === e) {
                            t.splice(r, 1);
                            break
                        }
                        let r = this.custom_words;
                        for (let t in r) if (r[t].word === e) {
                            r.splice(t, 1);
                            break
                        }
                    }
                },
                add_custom_word() {
                    let e = this.custom_word_data_input;
                    if (!e.word) return void i$.toast.info("请输入单词");
                    if (e.word = e.word.trim().replaceAll(" +", " ").replaceAll(" ", "-").replace(/-+/g, "-"), !/^[A-Za-z_ -.]+$/.test(e.word)) return void i$.toast.info("单词仅支持英文");
                    if (!e.pos) return void i$.toast.info("请选择词性");
                    if (!e.meaning) return void i$.toast.info("请输入词义");
                    const t = e.word,
                    r = e.pos,
                    i = e.meaning.replaceAll("；", ";").replaceAll("，", ",");
                    if (t.length > 80) return void i$.toast.info("单词最长 80 个字母");
                    if (i.length > 100) return void i$.toast.info("单个解释最长 100 个字");
                    this.custom_words;
                    let o = this.custom_words_data,
                    s = null;
                    for (let e in o) {
                        if (s = o[e], s.word === t) break;
                        s = null
                    }
                    s ? s.meanings[r] ? (s.meanings[r] += ";" + i, s.meanings[r].replaceAll(";+", ";")) : s.meanings[r] = i: (s = {
                        word: t,
                        meanings: {}
                    },
                    s.meanings[r] = i, this.custom_words.push(s.word), this.custom_words_data.push(s)),
                    this.custom_word_data_input.word = "",
                    this.custom_word_data_input.meaning = ""
                },
                duplicate(e) {
                    let t,
                    r = [],
                    i = {};
                    const o = [];
                    for (let s in e) t = e[s],
                    i[t] ? o.push(t) : (i[t] = !0, r.push(t));
                    return o.length > 0 && i$.toast.warn("有“" + o.length + "”个单词重复，已移除。"),
                    r
                },
                sort_book_words() {
                    let e = this.duplicate(this.user_book.words);
                    e.sort(((e, t) = >e > t ? 1 : e < t ? -1 : 0)),
                    this.user_book.words = e
                },
                random_book_words() {
                    this.user_book.words.sort((() = >Math.random() - .5))
                },
                search() {
                    let e = this.search_input;
                    e && (e = e.replace(/(^\s*)|(\s*$)/g, "").replace(/ +/g, "-"), i$.http.get("api/dict/en/zh/" + e.toLowerCase()).then((e = >{
                        e && (this.search_word.word = e.word, this.search_word.id = e.id, this.search_word.ukPhonetic = e.ukPhonetic, this.search_word.usPhonetic = e.usPhonetic)
                    })), this.search_input = "")
                },
                remind() {
                    i$.toast.info("感谢反馈，我们会尽快处理。(●'◡'●)"),
                    this.search_word = {
                        word: ""
                    }
                },
                save() {
                    let e = this.user_book;
                    if (!e.name) return void i$.toast.info("名称不能为空");
                    if (e.name.length > 30) return void i$.toast.warn("名称最长 30 个字符");
                    if (!e.words || 0 == e.words.length) return void i$.toast.info("单词不能为空");
                    let t,
                    r = this.new_words_data,
                    i = {};
                    for (let e = 0; e < r.length; e++) t = r[e],
                    i[t.word] = t.meanings;
                    e.wordsData = i;
                    let o = 0,
                    s = this.current_user();
                    if (o = this.book_size_limit(), !(e.words.length < 3)) return e.words.length > o ? (i$.toast.warn("目前每个单词书最大支持" + o + "个单词"), void("VIP" !== s.role && i$.toast.info("升级会员可导入 15000 个单词"))) : void i$.http.post("api/book/en/zh/book/update", e).then((e = >{
                        e && -1 != e.code ? i$.toast.info("保存成功！") : (i$.toast.warn(e.msg), e.msg.indexOf("limited to") && i$.toast.info("升级到赞助会员可以添加更多单词书")),
                        this.new_words_data = [],
                        this.toggle_add_modal(),
                        this.request_user_books(this.book_info)
                    })).
                    catch((e = >{
                        console.log(e),
                        this.toggle_add_modal()
                    }));
                    i$.toast.warn("自定义单词书最少3个单词")
                },
                book_size_limit() {
                    return "VIP" === this.current_user().role ? 15e3: 1e3
                },
                book_num_limit() {
                    return "VIP" === this.current_user().role ? 15 : 3
                },
                delete_book(e, t) {
                    t && t.bookId && i$.popup.confirm("确定删除《" + t.name + "》?\n删除后不可恢复 !", {},
                    (() = >{
                        i$.http.delete("api/book/en/zh/book/" + t.bookId).then((e = >{
                            e && (i$.toast.info("删除《" + t.name + "》成功"), this.request_user_books(i$.cache.get("book_info") || {}))
                        })).
                        catch((e = >{
                            console.log(e)
                        }))
                    }))
                },
                read_text_File(e) {
                    let t = new FileReader;
                    t.readAsText(e, "UTF-8"),
                    t.onload = e = >{
                        let t,
                        r = e.target.result.replace(/[^a-zA-Z]+/gi, ",").split(","),
                        i = [];
                        for (let e in r)(t = r[e]).length > 1 && i.push(t.toLowerCase());
                        let o = "";
                        this.import_words = this.duplicate(i);
                        let s = 0;
                        for (let e in i) {
                            if (s > 30) break;
                            s++,
                            o += i[e],
                            o += "、"
                        }
                        this.file_info = "文件共包含 " + o + "等" + this.import_words.length + "个单词"
                    }
                },
                read_excel_file(e) {
                    if (!e) return;
                    if ("undefined" == typeof ExcelJS || null == ExcelJS) return void i$.toast.warn("加载excel工具失败");
                    const t = new ExcelJS.Workbook;
                    let r = new FileReader;
                    r.readAsArrayBuffer(e),
                    r.onload = e = >{
                        t.xlsx.load(e.target.result).then((e = >{
                            i$.load.start();
                            const t = e.worksheets;
                            let r,
                            i = [],
                            o = [];
                            for (let e = 0; e < t.length; e++) {
                                let s,
                                n,
                                a;
                                r = t[e];
                                let d = 5e4;
                                for (let e = 1; o.length < d && (s = r.getRow(e), n = s.getCell(1), null != n.value); e++) {
                                    let e = "";
                                    if ("string" === n.value) e = n.value;
                                    else if (null != n && null != n.value && "object" == typeof n.value && n.value.richText) {
                                        let t = n.value.richText;
                                        for (let r = 0; r < t.length; r++) e += t[r].text
                                    } else e = new String(n.value);
                                    if (e = e.trim().replace(/[\r\n\t]+/g, " ").replace(/ +/g, "-"), e.length >= 130) continue;
                                    if (e.replace(/[^a-z]/gi, "").length <= 1) continue;
                                    a = s.getCell(2);
                                    let t = "";
                                    if ("string" == typeof a.value) t = a.value;
                                    else if (null != a.value && "object" == typeof a.value && a.value.richText) {
                                        let e = a.value.richText;
                                        for (let r = 0; r < e.length; r++) t += e[r].text
                                    } else t = new String(a.value);
                                    let r = this.process_excel_data(t);
                                    if (r.length > 0) {
                                        let t = {};
                                        for (let e = 0; e < r.length; e++) t[r[e].pos] = r[e].meaning;
                                        i.push(e.toLowerCase()),
                                        o.push({
                                            word: e.toLowerCase(),
                                            meanings: t
                                        })
                                    }
                                }
                            }
                            i$.load.finish(),
                            this.import_words = i,
                            this.import_words_data = o
                        })).
                        catch((e = >{
                            console.log(e)
                        }))
                    },
                    r.onerror = e = >{
                        console.log("read excel error")
                    },
                    r.onabort = e = >{
                        console.log("abort error")
                    }
                },
                read_csv_file(e) {
                    e && t().parse(e, {
                        encoding: "utf-8",
                        complete: (e, t) = >{
                            i$.load.start();
                            let r = [],
                            i = [];
                            if (e.data) {
                                let t,
                                o = e.data;
                                for (let e = 0; e < o.length; e++) if (t = o[e], t.length >= 2) {
                                    let e = this.process_excel_data(t[1].replace(/[\r\t\n]+/g, ";"));
                                    if (0 == e.length) continue;
                                    let o = {};
                                    for (let t = 0; t < e.length; t++) o[e[t].pos] = e[t].meaning;
                                    i.push(t[0]),
                                    r.push({
                                        word: t[0],
                                        meanings: o
                                    })
                                } else console.log(t)
                            }
                            i$.load.finish(),
                            this.import_words = i,
                            this.import_words_data = r
                        },
                        error: () = >{
                            i$.toast.warn("文件格式异常")
                        }
                    })
                },
                process_excel_data(e) {
                    if (!e || "string" != typeof e) return [];
                    e = e.replace(/[\r\t\n]+/g, " ").replace(/\s+/g, ";").replace(/。/g, ".").replace(/，/g, ",").replace(/；/g, ";").toLowerCase();
                    const t = ["v.", "vi.", "vt.", "n.", "adj.", "adv.", "prep.", "conj.", "modal.", "int.", "abbr.", "art.", "num.", "aux."];
                    let r,
                    i,
                    o,
                    s = [],
                    n = !1;
                    for (let o = 0; o < t.length; o++) for (r = t[o], i = -1; (i = e.indexOf(r, i + 1)) >= 0;) n = !0,
                    "v." === r && i > 0 && "d" === e[i - 1] || s.push({
                        pos: r,
                        index: i
                    });
                    n || (console.log("没有检测到词性：" + e), s.push({
                        pos: "other.",
                        index: e
                    })),
                    s.sort(((e, t) = >e.index - t.index));
                    let a = {};
                    if (1 == s.length) o = {
                        pos: s[0].pos,
                        meaning: e.substring(s[0].index + s[0].pos.length)
                    },
                    o.meaning.length > 0 && (o.meaning += ";", a[s[0].pos] = o);
                    else if (s.length > 1) {
                        let t,
                        r;
                        for (let i = 0; i < s.length - 1; i++) t = s[i],
                        r = s[i + 1],
                        null != (o = a[t.pos]) ? o.meaning += e.substring(t.index + t.pos.length, r.index) + ";": (o = {
                            pos: t.pos,
                            meaning: e.substring(t.index + t.pos.length, r.index)
                        },
                        o.meaning.length > 0 && (o.meaning += ";", a[t.pos] = o));
                        null != (o = a[r.pos]) ? o.meaning += e.substring(r.index + r.pos.length) + ";": (o = {
                            pos: r.pos,
                            meaning: e.substring(r.index + r.pos.length)
                        },
                        o.meaning.length > 0 && (o.meaning += ";", a[r.pos] = o))
                    }
                    let d = [];
                    for (let e in a) o = a[e],
                    o.meaning = o.meaning.replaceAll(/;+/g, ";").substring(0, 100),
                    o.meaning.startsWith(";") && (o.meaning = o.meaning.substring(1)),
                    d.push(o);
                    return d
                },
                next_import_words() {
                    Math.ceil(this.import_words_data.length / 50) - 1 > this.import_words_page && (this.import_words_page += 1)
                },
                pre_import_words() {
                    this.import_words_page > 0 && (this.import_words_page -= 1)
                },
                merge_book_selecting(e) {
                    this.merge_book.selecting = "A" === e || "B" === e ? e: ""
                },
                merge_book_clear() {
                    this.merge_book_type = "",
                    this.merge_book = {
                        newname: "",
                        selecting: "",
                        target_book: {},
                        target_book_detail: {},
                        other_book: {},
                        other_book_detail: {}
                    }
                },
                merge_book_select(e) {
                    if (!e) return;
                    if (e == this.merge_book.target_book.bookId || e == this.merge_book.other_book.bookId) return void i$.toast.info("请选择不同的单词书!");
                    const t = this.user_books;
                    let r = null;
                    for (let i in t) if (t[i].bookId === e) {
                        r = t[i];
                        break
                    }
                    null != r && ("A" == this.merge_book.selecting ? this.merge_book.target_book = JSON.parse(JSON.stringify(r)) : "B" == this.merge_book.selecting && (this.merge_book.other_book = JSON.parse(JSON.stringify(r))), this.merge_book_selecting(""))
                },
                merge_book_next() {
                    const e = this.merge_book;
                    if (!e) return;
                    if (!e.target_book.bookId) return void i$.toast.warn("请选择需要合并的单词书");
                    if (!e.other_book.bookId) return void i$.toast.warn("请选择需要合并的单词书");
                    this.merge_book_loaded_num = 0,
                    this.merge_book_start = !0;
                    const t = e.target_book.bookId;
                    i$.http.get("api/book/en/zh/book/custom/detail?id=" + t + "&needWordData=true").then((t = >{
                        if (t && t.id) {
                            this.merge_book.target_book_detail = t,
                            this.merge_book_loaded_num += 1;
                            const r = e.other_book.bookId;
                            i$.http.get("api/book/en/zh/book/custom/detail?id=" + r + "&needWordData=true").then((e = >{
                                e && e.id && (this.merge_book.other_book_detail = e, this.merge_book_loaded_num += 1)
                            })).
                            catch((e = >{
                                console.log(e)
                            }))
                        }
                    })).
                    catch((e = >{
                        console.log(e)
                    }))
                },
                merge_book_type_update(e) {
                    this.merge_book_type = "new" === e ? "new": "toa" === e ? "toa": ""
                },
                merge_book_submit() {
                    if (this.merge_book_loaded_num < 2) return void i$.toast.info("等待单词书加载完成");
                    const e = this.merge_book.target_book_detail;
                    console.log(JSON.parse(JSON.stringify(e)));
                    const t = this.merge_book.other_book_detail,
                    r = e.words.length,
                    i = t.words.length,
                    o = e,
                    s = this.book_size_limit();
                    this.current_user();
                    if (r + i > s) return i$.toast.warn("合并失败:目前每个单词书最大支持" + s + "个单词"),
                    void i$.toast.info("赞助会员可导入 15000 个单词");
                    if ("new" == this.merge_book_type) {
                        o.id = null;
                        const e = this.book_num_limit();
                        if (this.user_books.length >= e) return i$.toast.warn("当前权限只能创建(" + e + ")个单词书"),
                        void i$.toast.info("赞助会员可导入 15 个单词表");
                        if (!this.merge_book.newname) return void i$.toast.warn("先输入合并后的单词书名");
                        o.name = this.merge_book.newname
                    }
                    const n = e.words,
                    a = t.words;
                    let d = [];
                    for (let e in a) {
                        let t = a[e];
                        n.indexOf(t) < 0 && d.push(t)
                    }
                    if ("head" === this.merge_book_mode) o.words = d.concat(n);
                    else {
                        if ("tail" !== this.merge_book_mode) return;
                        o.words = n.concat(d)
                    }
                    o.wordsData = o.wordsData || {},
                    t.wordsData = t.wordsData || {};
                    for (let e in t.wordsData) o.wordsData[e] = t.wordsData[e];
                    i$.http.post("api/book/en/zh/book/update", o).then((e = >{
                        e && -1 != e.code ? i$.toast.info("合并成功！") : (i$.toast.warn(e.msg), e.msg.indexOf("limited to 3") && i$.toast.info("升级到赞助会员可以添加更多单词书")),
                        this.request_user_books(this.book_info),
                        this.merge_book_clear(),
                        this.toggle_merge_modal()
                    })).
                    catch((e = >{
                        console.log(e),
                        this.toggle_add_modal()
                    }))
                }
            },
            page_watch: {
                words_custom_add_backward: function(e, t) {
                    localStorage.setItem("$$words_custom_add_backward", e)
                }
            }
        },
        o = function(e) {
            return {
                id: e.id,
                name: e.name,
                title: e.properties.description,
                total: e.total,
                cover: e.cover,
                learning: e.learning,
                href: e.total > 0 ? "/book?id=" + e.id: "#"
            }
        };
        window.page_info = i
    })()
})();